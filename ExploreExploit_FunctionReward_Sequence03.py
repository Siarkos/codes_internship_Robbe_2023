import pandas as pd
import cv2
import time
import random
import numpy as np
import os
from paramiko import AutoAddPolicy, SSHClient
import EasyPySpin

##############################
#define main variables
experimenterName='Maud' #this is important to save your data proprely
mouseName='Tests'     #this is important to save your data proprely
CNO_injection='none' #can be 'none' when there is no injection or can be the injection time (hour/minutes)

SESSION_DURATION= 60 #change the RIGHT multipler according to the number of minutes you want your session (durationOfExperiment is in seconds)

EXPLORATION_DURATION = 0.1 #must be in seconds

#FUNCTION_TYPE = "habitat"
FUNCTION_TYPE = "linear_turns"
#FUNCTION_TYPE = "linear_decrease"
#FUNCTION_TYPE = "quadratic_time"
#FUNCTION_TYPE = "quadratic_turns"


TRAPEZE_SIZE=50

currently_rewarded_object = ['NW','SE'] ; potentialRewardedObjects = ['NW','SE'] #seperate the definition so the two do not refrence the same object

DIRECTION_TYPE = 2 # 1 for all direction possible, 0 for random, 2 for no discrimination
DECRESASE_WITH_TIME = False #if the rewards chances does not decrease with time, they decrase with the number of reward obtained on the object
TIME_SINCE_LAST_REWARD = False # if true then since_last_reward is the time at which the last reward was obtained
                                # if false, it's the number of quarter turn around that object since the last reward was obtained

potentialRewardedDirections=[270]

OBJECT_REWARD_RATE = {"NW" : 0,
                      "NE" : 0,
                      "SW" : 0,
                      "SE" : 0}

SLOPE = 0.2
PLATEAU = 100
DELAI = 3

#EXPLORATION_TYPE = 0 #any object
EXPLORATION_TYPE = 1 # a different object


#Individual valves flow adjustment : here you can set-up the flow of each valve, every day if needed. Below, you can find the identification of each valve
#in the comments section + the dictionary containing : the ID of the valve (first on green) and the flow (second in yellow)
#NW object : 12pm = '0' ; 9pm = '1' ; 6pm = '2' ; 3pm = '3'
#NE object : 12pm = '4' ; 9pm = '5' ; 6pm = '6' ; 3pm = '7'
#SW object : 12pm = '8' ; 9pm = '9' ; 6pm = '10'; 3pm = '11'
#SE object : 12pm = '12'; 9pm = '13'; 6pm = '14'; 3pm = '15'
open_times = {'0':0.5, '1':0.2, '2':0.1, '3':0.5, '4':0.1, '5':0.5, '6':0.2, '7':0.2, '8':2, '9':0.2, '10':2, '11':0.08, '12':0.08, '13':0.08, '14':0.08, '15':0.08}


####################################################################################################################
#define important functions

#in order for the function to correctly work, the first right turn must always be reward in the current version
def reward_function(x, patch, since_last_reward) : #give back the probability of reward
    
    # p  is the probability to get aSLOPE * (x - DELAI) reward
    
    #if using a depleting patch tye of environnement
    if FUNCTION_TYPE == "linear_decrease" : 
        if x < DELAI : p = 1
        else : p = 1 - SLOPE * (x - DELAI)
        if p < PLATEAU : p = PLATEAU

    #if using a set chance by patch
    elif FUNCTION_TYPE == "habitat" : 
        p = OBJECT_REWARD_RATE[patch]

    elif FUNCTION_TYPE == "quadratic_time" : 
        if x < DELAI : t = 0
        else : t = SLOPE * (x - DELAI) * (x + 1 - DELAI) / 2 # each time a new consecutive reward is obtained increase the time necessary to get the next reward by the number of reward obtained * slope
        if t > PLATEAU : t = PLATEAU

        if time.time() - since_last_reward >= t : 
            p = 1
        else :
            p = 0

    elif FUNCTION_TYPE == "quadratic_turns" :
        if x < DELAI : t = 0
        else : t = SLOPE * (x - DELAI) * (x + 1) / 2 # each time a new consecutive reward is obtained increase the time necessary to get the next reward by the number of reward obtained * slope
        if t > PLATEAU : t = PLATEAU

        if since_last_reward >= t : 
            p = 1
        else :
            p = 0
    
    elif FUNCTION_TYPE == "linear_turns" : 
        if x < DELAI : t = 0
        else : t = SLOPE * (x - DELAI) # [SLOPE] more turns than the previous one are requiered to get the reward 
        if t > PLATEAU : t = PLATEAU

        if since_last_reward >= t : 
            p = 1
        else :
            p = 0

    else : raise NameError("invalid function_type")

    if random.random() <= p : return 1 #see if the random value is greater value than the current threshold, given by the first part and a degressive function
    else : return 0

def trapezes_from_patch(patch, width):
    """
    generate the trapezes coordinates surrounding a patch
    inputs:
    patch - coordinates of a patch [[Xa, Ya], [Xb, Yb], [Xc, Yc], [Xd, Yd]]
    width - width of the trapeze in pixels
    outputs:
    coordinates [[Xa, Ya], [Xb, Yb], [Xc, Yc], [Xd, Yd]] for the 4 trapezes.
    
    trapezes_from_patch(SWpatch_coords, 200)
    """

    N = [patch[0], patch[1], [patch[1][0]+width, patch[1][1]-width], [patch[0][0]-width, patch[0][1]-width]]
    E = [patch[1], patch[2], [patch[2][0]+width, patch[2][1]+width], [patch[1][0]+width, patch[1][1]-width]]
    S = [patch[2], patch[3], [patch[3][0]-width, patch[3][1]+width], [patch[2][0]+width, patch[2][1]+width]]
    W = [patch[3], patch[0], [patch[0][0]-width, patch[0][1]-width], [patch[3][0]-width, patch[3][1]+width]]
    return N, E, S, W


def points_in_polygon(polygon, pts):
    pts = np.asarray(pts,dtype='float32')
    polygon = np.asarray(polygon,dtype='float32')
    contour2 = np.vstack((polygon[1:], polygon[:1]))
    test_diff = contour2-polygon
    mask1 = (pts[:,None] == polygon).all(-1).any(-1)
    m1 = (polygon[:,1] > pts[:,None,1]) != (contour2[:,1] > pts[:,None,1])
    slope = ((pts[:,None,0]-polygon[:,0])*test_diff[:,1])-(test_diff[:,0]*(pts[:,None,1]-polygon[:,1]))
    m2 = slope == 0
    mask2 = (m1 & m2).any(-1)
    m3 = (slope < 0) != (contour2[:,1] < polygon[:,1])
    m4 = m1 & m3
    count = np.count_nonzero(m4,axis=-1)
    mask3 = ~(count%2==0)
    mask = mask1 | mask2 | mask3
    return mask[0]



def solenoID(currentPatch, currentTrapeze):
    valvePatch = {'NW':0, 'NE':4, 'SW':8, 'SE':12}  # sur video : NE == objet 3, SE == obj 1 , NW == obj 4, SW == obj 2
    valveTrapeze = {'N':0, 'E':1, 'S':2, 'W':3}
    if str(currentTrapeze) != 'none':
        return valvePatch[currentPatch] + valveTrapeze[currentTrapeze]
    

def angle_between(p1, p2):
    ang1 = np.arctan2(*p1[::-1])
    ang2 = np.arctan2(*p2[::-1])
    return np.rad2deg((ang1 - ang2) % (2 * np.pi)) 

#############################################################################################
#define main function


def main():

    ################################################################################################################
    #creat the figure
    resolution = 512,512 


    global experimenterName, currently_rewarded_object, mouseName, CNO_injection, potentialRewardedDirections, potentialRewardedObjects
    ## coordinates of the objects
    ## beware that those coordinates repeat the first point (this allows drawing them easily)
    NWpatch_coords = [[104, 125], [173, 125], [173, 201], [104, 201]]
    NEpatch_coords = [[330, 120], [400, 120], [400, 200], [330, 200]]
    SWpatch_coords = [[109, 351], [181, 351], [181, 410], [109, 410]]
    SEpatch_coords = [[330, 350], [400, 350], [400, 410], [330, 410]]

    if DIRECTION_TYPE == 0 :
        currently_rewarded_direction = [potentialRewardedDirections[random.randrange(0, 2)]]#get the possible patch and direction for next rewards
    elif DIRECTION_TYPE == 1 or DIRECTION_TYPE == 2 :
        currently_rewarded_direction = potentialRewardedDirections
    else : raise IndexError

    #intialize the variable
    since_last_reward = 0

    ##generate the trapeze around each object


    trapezes = {"NW" : trapezes_from_patch(NWpatch_coords, TRAPEZE_SIZE),
                "NE" : trapezes_from_patch(NEpatch_coords, TRAPEZE_SIZE),
                "SW" : trapezes_from_patch(SWpatch_coords, TRAPEZE_SIZE),
                "SE" : trapezes_from_patch(SEpatch_coords, TRAPEZE_SIZE)}

#    for thispatch in ["NW", "NE", "SW", "SE"]:
#        N, E, S, W = trapezes[thispatch]
#        for thispath in [N, E, S, W]: 
#            thispath.append(thispath[0])
#            path = Path(thispath, codes)
#            patch = patches.PathPatch(path, facecolor='w', linestyle='--',lw=1)
#            ax.add_patch(patch)

    # position of all the water ports. (this could be redone using the the patch coordinates)
    # water we start by NW objects from noon in a clockwise manner
    waterports = {0:((104+173)/2,125), 1:(173, (125+201)/2), 2:((104+173)/2, 201), 3:(104,(125+201)/2),
                        4:(365, 120), 5:(400, 160), 6:(365, 200), 7:(330, 160),
                        8:((109+181)/2, 351), 9:(181, (351+418)/2), 10:((109+181)/2, 418), 11:(109, (351+418)/2),
                        12:((330+400)/2, 350), 13:(400, (350+420)/2), 14:((330+400)/2, 420), 15:(330, (350+420)/2)}
#    for key,value in waterports.items() :
#        ax.scatter(value[0],value[1],c='w',marker='o',edgecolors='k')

    objectCardinalPosition=['NW','NE','SW','SE'] #currently the code confuse quadrant and object under the name of patches.
    cardinalvectors= {'N': (0,1),'E': (1,0),'S': (0,-1),'W': (-1,0)} # those vectors point in the direction of the 4 reward ports from the center of the object

    # for nameindex,waterportindex in enumerate(np.arange(0,16,4)): #add the name of the object on them
    #     ax.text(waterports[waterportindex][0],waterports[waterportindex+1][1], objectCardinalPosition[nameindex],horizontalalignment='center',
    #      verticalalignment='center')
        

    #############################################################################################
   

    theoreticalsamplingrate=25
    timeofframes=np.empty([SESSION_DURATION*(theoreticalsamplingrate+2),3])
    timeofframes[:]=np.nan

    timestr = time.strftime("%Y%m%d-%H%M") #day-time to add in saved data
    dataFolderPath= '/media/david/datadrive/data/'#you are not supposed to change this
    sessionName=mouseName+ '_'+ timestr
    experimentFolderPath=dataFolderPath + experimenterName + '/' + mouseName + '/' + sessionName
    os.mkdir(experimentFolderPath)  ### create a new folder in your mouse forlder where to save all the data geenrated by this code
                                    ### video avi file, typeofturn csv file, time/xpos/ypos of detected animal centroid,param file (to be done)
    videotosave_FullPath=experimentFolderPath + '/' + sessionName + '.avi'
    turnsinfoCSV_FullPath=experimentFolderPath + '/' + sessionName + '_turnsinfo.csv'
    centroid_time_XYposCSV_FullPath=experimentFolderPath + '/' + sessionName + '_centroidTXY.csv'
    sessionParametersCSV=experimentFolderPath + '/' + sessionName + '_sessionparam.csv'



    # video resolution
    resolution = 512,512
    fourcc = cv2.VideoWriter_fourcc(*'XVID')
    out = cv2.VideoWriter(videotosave_FullPath, fourcc, theoreticalsamplingrate, (resolution), False)


    RASPBERRY_IP = '10.51.106.8'
    GPIO = {'0':1, '1':3, '2':0, '3':2, '4':15 , '5':99, '6':14, '7':12, '8':9, '9':11, '10':10, '11':5, '12':26, '13':13, '14':6, '15':19}

    #############################################################################################
    #setup environnement for the main function
    x_positions,y_positions = [0, 0], [0, 0]; _x = _y = 0

    past_presentPatch = [None, None]
    past_presentTrapeze = [None, None]

    exploring = True #initialize as if an exploration as been started and the time was completed
    exploration_start_time = 0
    current_point_in_reward = 0
    total_reward = 0
    explotation_start_time = 0
    framenumber = 0
    rewardedSolenoid = 0.5

    future_dataframe = [] #list which will contain the informations on the session
    

    client = SSHClient()
    client.set_missing_host_key_policy(AutoAddPolicy())  # missing host key, bypass with this. Not sure it's ok security-wise. 
    client.connect(RASPBERRY_IP, username='pi', password='rlovy19')
    

    


    cap = EasyPySpin.VideoCapture(0)
    if not cap.isOpened():
        print("Camera can't open\nexit")
        raise SystemError
    
    print("start of the session")
    cap.set(cv2.CAP_PROP_EXPOSURE, -1)  # -1 sets exposure_time to auto
    cap.set(cv2.CAP_PROP_GAIN, -1)  # -1 sets gain to auto

    fgbg = cv2.createBackgroundSubtractorMOG2()



    for a in range(50) : #use the first 50 frames of the video with a higher learning rate for background substraction so the mouse is detected quicker
        ret, frm = cap.read()
        frm = cv2.resize(frm, (resolution), interpolation = cv2.INTER_AREA)           
        frame_video=frm      
        out.write(frame_video)
        
        kernelSize = (25,25)
        frameBlur = cv2.GaussianBlur(frm, kernelSize, 0)

        # apply the background substraction
        thresh = fgbg.apply(frameBlur,learningRate=0.004)
        cv2.imshow("__", thresh)
        key = cv2.waitKey(10)


    time_start_session = time.time()
    time_end_session = time_start_session + SESSION_DURATION


    while time.time() < time_end_session : #real beginning of the session
        deliverReward = False
        time_frame = round(time.time() - time_start_session, 3) #time of the frame
        
        ret, frm = cap.read()#read the next frame of the video
        frm = cv2.resize(frm, (resolution), interpolation = cv2.INTER_AREA) #change the resoltution of the frame

        frame_video=frm      
        out.write(frame_video) #write the video without other treatement
        
        kernelSize = (25,25)
        frameBlur = cv2.GaussianBlur(frm, kernelSize, 0)#apply a blur to the frame to make details disapear

        # apply the background substraction
        thresh = fgbg.apply(frameBlur,learningRate=0.0004)#background substraction


        M = cv2.moments(thresh) #get the spatial repartition of pixels which are not part of the background
        if M['m00'] == 0: continue #if this value is 0, do not compute this frame and go to the next
        x = int(M['m10'] / M['m00'])
        y = int(M['m01'] / M['m00'])#get the x and y values of the centoid, so the position of the mouse
        if _x == 0 and _y == 0:#if this is the first frame, set the position i
            _x = x
            _y = y
        
        timeofframes[framenumber,:]=[time_frame,x,y]
        framenumber+=1
        #set the necessary variables as global
        #update the position
        x_positions.append(x)
        y_positions.append(y)


        ###############################################################################################
        #get the current Patch and Trapeze the mouse is currently in, and update the past_present list
                
        if x <= resolution[0]/2 and y <= resolution[0]/2: #patch NW
            currentPatch = 'NW'
        elif x >= resolution[0]/2 and y<=resolution[0]/2: #patch NE
            currentPatch = 'NE'
        elif x <=resolution[0]/2 and y>=resolution[0]/2: #patch SW
            currentPatch = 'SW'
        elif x >=resolution[0]/2 and y>=resolution[0]/2: #patch SE
            currentPatch = 'SE'

        N, E, S, W = trapezes[currentPatch]


        if points_in_polygon(N, [[x, y]]): 
            currentTrapeze = 'N'
        if points_in_polygon(E, [[x, y]]): 
            currentTrapeze = 'E'
        if points_in_polygon(S, [[x, y]]): 
            currentTrapeze = 'S'
        if points_in_polygon(W, [[x, y]]): 
            currentTrapeze = 'W'
        if not points_in_polygon(N, [[x, y]]) and not points_in_polygon(E, [[x, y]]) and not points_in_polygon(S, [[x, y]]) and not points_in_polygon(W, [[x, y]]): 
            currentTrapeze = 'none'

        if len(x_positions) == 1 :
            past_presentPatch[0] = currentPatch
            past_presentTrapeze[0] = currentTrapeze

        else : 
            past_presentTrapeze[0:2] = past_presentTrapeze[1], currentTrapeze
            past_presentPatch[0:2] = past_presentPatch[1], currentPatch

            ################################################################################
            #manage the Patch changes
            if past_presentPatch[0] != past_presentPatch[1] :#check if the object change
                if not exploring : 
                    exploration_start_time = time.time()#if the mouse is not currently exploring, strat an exploration
                    exploring = True
                    current_point_in_reward = 0
                    since_last_reward = 0 #reset the counters

                    if EXPLORATION_TYPE == 1 :

                        #get the list of all rewarded object
                        copy_list_reward = [object for object in potentialRewardedObjects]
                        #take out the object the mouse just left
                        copy_list_reward.remove(past_presentPatch[0])
                        #the result is the currently rewarded object
                        currently_rewarded_object = copy_list_reward

                #if an exploration have started, the timer is active and the time is over
                if exploration_start_time != 0 and (time.time() - exploration_start_time) > EXPLORATION_DURATION: 
                    if DIRECTION_TYPE == 0 :
                        currently_rewarded_direction = potentialRewardedDirections[random.randrange(0, 2)]#get the possible patch and direction for next rewards
                    elif DIRECTION_TYPE == 1 :
                        currently_rewarded_direction = potentialRewardedDirections
                    #currently_rewarded_object = potentialRewardedObjects
                    exploration_start_time = 0 #signal that the timer is over


                        
                if past_presentPatch[0] is not None : print("changing patch")
            
                #else, do nothing

            ##################################################################################
            #manage the trapeze change (elif because we do not want the mouse jumping from a trapeze in an object to one in the following)
            elif (past_presentTrapeze[0] != past_presentTrapeze[1]) and not 'none' in past_presentTrapeze:
                
                thisdirection = angle_between(cardinalvectors[past_presentTrapeze[1]],cardinalvectors[past_presentTrapeze[0]])
                if 0 != exploration_start_time : #if the timer for exploration is set, no reward can be deliverd
                    deliverReward = False
                    type_of_turn = "expl"

                elif thisdirection not in currently_rewarded_direction : #if the animal does not go into the right direction

                    deliverReward = False
                    if currentPatch in currently_rewarded_object : type_of_turn = "gobd" #note the type of turn when the direction is bad but the object is good
                    else : type_of_turn = "bobg"

                else :
                    if not currentPatch in currently_rewarded_object : type_of_turn = "bogd" #note the type of turn when the direction is good but the object is bad
                    
                    else:
                        deliverReward = True
                        type_of_turn = "gogd"

                        if current_point_in_reward == 0 :# check if this is the first reward given after an exploration. If yes, fix the object and end exploration
                            currently_rewarded_object = [currentPatch]
                            if DIRECTION_TYPE != 2 : currently_rewarded_direction = [thisdirection]
                            exploring =  False
                            
                        
                        if DECRESASE_WITH_TIME : 
                            if current_point_in_reward == 0:
                                reward = reward_function(0, currentPatch, since_last_reward)
                                explotation_start_time = time.time()
                            else : reward = reward_function(time.time() - explotation_start_time, currentPatch, since_last_reward)
                        else :
                            reward = reward_function(current_point_in_reward, currentPatch, since_last_reward)
                        if reward : #so if the value of the reward is greater than 0. Used for probability of getting the reward
                            rewardedSolenoid = solenoID(currentPatch, currentTrapeze)
                            command = f'python3 /home/pi/valvesT.py --ID={str(GPIO[str(rewardedSolenoid)])} --opentime={str(open_times[str(rewardedSolenoid)])}'
                            stdin, stdout, stderr = client.exec_command(command)
                            deliverReward = True
                            current_point_in_reward += 1
                            total_reward = total_reward + reward
                            print("consec reward : "+ str(current_point_in_reward) + "\nTotal number of reward : [" + str(total_reward) + "]\n")

                            if TIME_SINCE_LAST_REWARD : #update since_last_reward so it reflect that a reward was just obtained
                                since_last_reward = time.time()
                            else :
                                since_last_reward = 0

                        else : 
                            type_of_turn = "bogd"
                            deliverReward = False
                            if not TIME_SINCE_LAST_REWARD : 
                                since_last_reward += 1
                        
                        
                
                if not deliverReward : 
                    print("No reward found\n")
                    reward = 0

                #save informations under the format : time, framenumber, xposition, yposition, current_object, previous_trapeze, current_trapeze, turn_direction, rewarded_object, rewarded_direction, type_of_turn, rewarde_size, number_of_consec_reward, total_of_reward
                future_dataframe.append([time_frame, framenumber, x_positions[-1], y_positions[-1], currentPatch, past_presentTrapeze[0], past_presentTrapeze[1], thisdirection, currently_rewarded_object, currently_rewarded_direction, type_of_turn, deliverReward, current_point_in_reward, total_reward])

                


        #show the detected shape            
        cv2.imshow("__", thresh)
        # update past values 
        _x = x
        _y = y
        key = cv2.waitKey(10)


    #########################################################
    #after the while is over
    df = pd.DataFrame(future_dataframe)
    df.columns=['time','framenumber','xposition','yposition','currentPatch','previousTrapeze','currentTrapeze','turnDirection','ongoingRewardedObject','ongoingRewardedDirection','typeOfTurn','Rewarded','nberOfConsecRewards','totalnberOfRewards']    
    df.to_csv(turnsinfoCSV_FullPath, sep=',', index=False)
        
    dfsamplingtimes=pd.DataFrame(timeofframes)
    dfsamplingtimes.columns=['time','xposition','yposition']
    dfsamplingtimes.to_csv(centroid_time_XYposCSV_FullPath, sep=',', index=False) #test

    parameters=[[experimenterName,mouseName,SESSION_DURATION,potentialRewardedDirections,potentialRewardedObjects, DIRECTION_TYPE, EXPLORATION_DURATION, FUNCTION_TYPE]]
    column_name = ['experimenterName','mouseName','durationOfExperiment','potentialRewardedDirections','potentialRewardedObjects', "choiceNextDirection", "explorationDuration", "rewardFunctionType"]

    if FUNCTION_TYPE == "habitat" : #add some parameters depending on the type of the function
        parameters[0].extend([OBJECT_REWARD_RATE['NW'], OBJECT_REWARD_RATE['NE'], OBJECT_REWARD_RATE['SW'], OBJECT_REWARD_RATE['SE']])
        column_name.extend(["probaNW", "probaNE", "probaSW", "probaSE"])
    elif FUNCTION_TYPE == "linear_decrease" or FUNCTION_TYPE == "quadratic_time" or  FUNCTION_TYPE == "quadratic_turns" or FUNCTION_TYPE == "linear_turns": 
        parameters[0].extend([SLOPE, PLATEAU, DELAI])
        column_name.extend(["slopeValue", "plateauValue", "delai"])
    else : 
        print("function not recognized ! not by hand the function and the variables")

    df=pd.DataFrame(parameters)
    df.columns= column_name
    df.to_csv(sessionParametersCSV, sep=',', index=False)

    out.release()
    cap.release()
    cv2.destroyAllWindows()
    
##############################
print("duration of experiment : " + str(SESSION_DURATION))                       
                
if __name__ == "__main__":
    main()





